cat
mostra o conteudo de um arquivo

There are two commonly used pager commands:

    The **less** command provides a very advanced paging capability. It is usually the default pager used by commands like the man command.
    The **more** command has been around since the early days of UNIX. While it has fewer features than the less command, however, the less command isn't included with all Linux distributions. The more command is always available.

HEAD AND TAIL

head 
show the first 10 lines

tail 
show the last 10 lines

tail -3 filename.txt -> irá mostrar as 3 últimas linhas do arquivo
tail -3 filename.txt é igual a tail -n 3 filename.txt


The pipe | character can be used to send the output of one command to another.


the **nl** command,  adds line numbers to the output.

**Input/Output Redirection**

STDIN

Standard input, or STDIN, is information entered normally by the user via the keyboard.

STDOUT

Standard output, or STDOUT, is the normal output of commands. When a command functions correctly (without errors) the output it produces is called STDOUT.

STDERR

Standard error, or STDERR, is error messages generated by commands. By default, STDERR is displayed in the terminal window where the command is executing. STDERR is also known as stream or channel #2.

Using the > character, the output can be redirected to a file instead:

It is also possible to preserve the contents of an existing file by appending to it. Use two arrow >> characters to append to a file instead of overwriting it:

Ao usar > ele adiciona o texto e/ou a saida para um arquivo(novo ou existente), funciona uma única vez, caso precise adicionar mais conteúdo, será sobreescrito, nesse utiliza-se o >> para complemento/adicionar mais coisas;


the **2>** indicates that all error messages should be sent to the file error.txt, which can be confirmed using the cat command:

To redirect stderr (error messages) to a file, issue the following command:

find /etc -name hosts 2> err.txt
cat err.txt
You can also redirect stdout and stderr into two separate files.

find /etc -name hosts > std.out 2> std.err
cat std.err
cat std.out

Both STDOUT and STDERR can be sent to a file by using the ampersand & character in front of the arrow > character. The &> character set means both 1> and 2>:


The **wc** command provides the number of lines, words and bytes (1 byte = 1 character in a text file) for a file, and a total line count if more than one file is specified.



The **cut** command can extract columns of text from a file or standard input. It’s primarily used for working with delimited database files.

FILTER FILE CONTENTS
**grep**
The grep command can be used to filter lines in a file or the output of another command that matches a specified pattern. That pattern can be as simple as the exact text that you want to match or it can be much more advanced through the use of regular expressions.

O grep pega o conteudo do arquivo(não de pastas);

- -c retorna a quantidade de linha no arquivo que batem com o objeto da pesquisa.
  

- -n retorna a pesquisa com o Nº da linha ao lado


- -v pega todo o conteudo do arquivo que não bate com os dados de busca.

- -i ignora a capitalização
the period . character. It matches any character except for the new line character. Consider the unfiltered contents of the ~/Documents/red.txt file:

grep 'r..f' red.txt
reef
roof


The square brackets [ ] match a single character from the list or range of possible characters contained within the brackets.


grep '[0-9]' profile.txt
I am **37** years old.
**3121991**
I have **2** dogs.
**123456789101112**

$ can be used to ensure a pattern appears at the end of the line, thereby effectively reducing the search results. 
grep 'r$' alpha-first.txt
B is for Bea**r**
F is for Flowe**r**

? 	Matches previous character zero or one time, so it is an optional character
+ 	Matches previous character repeated one or more times
| 	Alternation or like a logical "or" operator

To match colo followed by zero or one u character followed by an r character:

sysadmin@localhost:~/Documents$ grep -E 'colou?r' spelling.txt
American English: Do you consider gray to be a color or a shade?
British English: Do you consider grey to be a colour or a shade?

To match one or more e characters:

sysadmin@localhost:~/Documents$ grep -E 'e+' red.txt
red
reef
reeed
reed
reel
read                     

To match either gray or grey:

sysadmin@localhost:~/Documents$ grep -E 'gray|grey' spelling.txt
American English: Do you consider gray to be a color or a shade?
British English: Do you consider grey to be a colour or a shade?

The **find** command will begin the search in the directory specified and recursively search all of the subdirectories.

find Desktop -name "*nome do que voce quer procurar*"

find /etc -name hosts > find.out 2>&1    

The 2>&1 part of the command means "send the stderr (channel 2) to the same place where stdout (channel 1) is going".

The **tr**command accepts keyboard input (stdin), translates the characters and then redirects the output to stdout.

The grep command uses basic regular expressions, special characters like wildcards that match patterns in data. The grep command returns the entire line containing the pattern that matches.

The -E option to the grep command can be used to perform searches with extended regular expressions, essentially more powerful regular expressions. Another way to use extended regular expressions is to use the egrep command.

The fgrep command is used to match literal characters, ignoring the special meaning of regular expression characters.


sintaxe do grep

procure(grep) isso(oque quero procurar) aqui(local onde quero procurar)

grep sshd passwd

procure por sshd no arquivo passwd

^ -> expressão regular que especifica o começo,
only lines that begin with root should be matched and displayed:
    grep '^root' passwd

The pipe character, |, or "alternation operator", acts as an "or" operator. For example, execute the following to attempt to match either sshd, root or operator

grep 'sshd|root|operator' passwd



...