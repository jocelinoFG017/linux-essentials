###### Tornando um script executável

Todo script deve começar com o Shebang:
    #!/bin/bash

1. Crie o script

```sh
echo 'echo "Helll_World"' > test-script
```
o Bash tem uma variável de ambiente que contém todos os
diretórios em que ficam os comandos que queremos executar.
($PATH)
O shell espera encontrar um comando em cada um desses locais, delimitado por dois pontos (:).

2. Conceda a permissão de execução ao arquivo

```sh
    chmod +x test-script
```
3. Rode o script

```sh
    ./test-script
```

###### Editores de texto

##### Vi(m de iMproved)
i   -> Entrar no modo inserção
esc -> Sair do modo inserção
:   -> Entrar no modo de comando

HJKL -> Modo de navegação

##### nano

digitação já acontece no inicio
ctrl -> Acessar ferramentas

###### Variáveis

Declarado uma variavel

```sh
    username=Caroline
```
Note que **não há espaços** entre o nome da variável, o sinal de igual ou o valor atribuído.
Obs: **Tudo** é **tratado** como **string** inclusive os números.

Mostrando a variavel
```sh
    echo "Hello_$username"
```
Ao digitar **$username** no comando, indicamos que estamos **trocando** 
o **nome** de uma variável **pelo** **valor** atribuído a essa variável.

Observe que:
As **variáveis** devem conter apenas caracteres alfanuméricos ou sublinhados (underline) e
**diferenciam** **maiúsculas** de **minúsculas**. Username e username serão tratados como variáveis
distintas.

###### Variáveis e aspas duplas

Isso resultará em um erro, porque não pode haver espaços na declaração da variável...
```sh
    username=Caroline Silva Pinto
```
Neste caso utilizamos das aspas duplas ("")

Isto não irá gerar um erro.
```sh
    username="Caroline Silva Pinto"
```

As aspas duplas e simples comportam-se de maneira diferente.

As aspas duplas permitem que o intérprete efetue a substituição dentro das aspas. Aspas simples impedem a substituição.
ex: 
```sh
    username="Caroline Silva Pinto"
    echo "Hello_$username"
    echo 'Hello_$username'
```
Saída: 

```sh
    Hello_Carol silva pinto
    Hello_$username
```

###### Argumentos

Neste caso o argumento deverá ser inserido na chamada do script.
```sh
    username=$1
    echo "Hello_$username"
```
Ex: **./filename.sh Caroline**

Saída:
     Hello_Caroline

Ao utilizarmos mais de um argumento $2, $3 e etc. Caso um argumento não seja passado será considerado nulo, e não haverá mensagem de erro

###### Retorno do Nº de Argumentos

Enquanto variáveis como $1 e $2 contêm o valor dos argumentos posicionais, a variável $#
contém o número de argumentos.

Ex de if:

```sh
    if [ $# -eq 1 ]
    then    
        username=$1
        echo "Hello_$username"
    else
        echo "Somente um argumento é aceito"
    fi
```

Algumas outras comparações: 
* -ne Diferente de
* -gt Maior que
* -ge Maior que ou igual a
* -lt Menos que
* -le Menos que ou igual a
* -eq Igual a

###### Debug
O código de saída do último comando a ser executado será armazenado na variável $?.
ao usar echo $? será retornado 0 em caso de sucesso e 1 em caso de fracasso.

Existem duas variáveis internas que contêm todos os argumentos passados para o script: $@ e $*.

- **shift** Remove o primeiro elemento de um arranjo.

###### Loops for

ex:

```sh
    #!/bin/bash

    if [ $# -eq 0 ]
    then
        echo "Nenhum argumento fornecido. Por favor, forneça pelo menos um argumento."
        exit 1
    else
        echo -n "Hello $1"
        shift
        for username in $@
        do
            echo -n " , and $username"
        done
        echo "!"
        exit 0
    fi
```

Ao usar -n com echo , suprimimos a nova linha após a impressão.

###### Verificando erros com expressões regulares

Podemos querer verificar todos os argumentos que o usuário está inserindo.